[ { "title": "又记一次复杂项目迁移", "url": "/posts/%E5%8F%88%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%8D%E6%9D%82%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB/", "categories": "", "tags": "运维, python, fastdfs", "date": "2024-06-13 00:20:45 +0800", "snippet": "前言是的，项目迁移它又来了，还是22年那个项目，不同的是公司上了devops，所有组件都容器化了，免去了安装的过程，但是文件还得迁移那，又是罪恶滔天的fdfs，文件存的很凌乱，有的在富文本里有的在结构化数据库里，但不同的是我学会了python，py真的天下第一,太方便了家人们。这次解决问题的思路如下: 导出全量sql python正则选取文件url [re] 下载再上传 [requests、fdfs-client-py3==1.0.0] 全局替换文件url [pathlib2==2.3.7.post1] 进度条输出[tqdm==4.66.4]相较于22年的那次迁移，这次避免了数据库交互，运用了py，极大地提升了效率代码部分1. 首先给到的是fdfs上传部分，需要两个配置文件对应A和B fdfs客户端，py3下载会有点问题，所以用了request库下载A客户端文件流，再传到B客户端,返回一个可以直接访问的nginx地址# -*- coding: utf-8 -*-import tracebackfrom fdfs_client.client import Fdfs_clientimport requestsimport loggingnginx_url = &#39;xxx:8888&#39;logging.captureWarnings(True)class FastDFSHandler: def __init__(self, client_file_a, client_file_b): self.client_a = self.create_client(client_file_a) self.client_b = self.create_client(client_file_b) def create_client(self, client_file): try: client = Fdfs_client(client_file) return client except Exception as e: print(f&quot;FastDFS Create client fail: {e}&quot;) return None def download_from_a_upload_to_b(self, file_id, extname): try: # Download from A FastDFS # ret_download = self.client_a.download_to_buffer(file_id) # if not ret_download: # print(f&quot;Failed to download file from A FastDFS (File ID: {file_id})&quot;) # return False # Upload to B FastDFS ret_upload = self.client_b.upload_by_buffer(requests.get(file_id, verify=False).content, ) # ret_upload = self.client_b.upload_by_buffer(ret_download[&#39;Content&#39;], # file_ext_name=extname) if not ret_upload: print(f&quot;Failed to upload file to B FastDFS&quot;) return False url = nginx_url + ret_upload[&#39;Remote file_id&#39;] # print(f&quot;File successfully transferred from A to B FastDFS (File ID: {url})&quot;) return url except Exception as e: print(f&quot;Error during transfer: {e}&quot;) return &#39;&#39;def init(): # 你需要提供 A 和 B FastDFS 的配置文件路径 client_file_a = &quot;client_a.conf&quot; client_file_b = &quot;client_b.conf&quot; handler = FastDFSHandler(client_file_a, client_file_b) return handler# 使用示例# if __name__ == &quot;__main__&quot;:# client_file_a = &quot;client_a.conf&quot;# client_file_b = &quot;client_b.conf&quot;# handler = FastDFSHandler(client_file_a, client_file_b)# # 从 A FastDFS 下载并上传到 B FastDFS# handler.download_from_a_upload_to_b(source_file_id)客户端示例# connect timeout in seconds# default value is 30sconnect_timeout=10# network timeout in seconds# default value is 30snetwork_timeout=10# tracker_server 可以出现多次，格式为 &quot;host:port&quot;，host 可以是主机名或 IP 地址tracker_server=xxxx:22122# standard log level as syslog, case insensitive, value list:# emerg for emergency# alert# crit for critical# error# warn for warning# notice# info# debuglog_level=debug2.接下来是对sql文件的正则查找以及替换import re# 从pathlib2模块导入Pathfrom pathlib2 import Pathimport fastdfs_trans1 as fastdfs_transfrom tqdm import tqdmfile_path = &quot;2024-06-12tablecontent.sql&quot;# 创建一个函数来替换文本def replacetext(search_text, replace_text): # 使用Path函数打开文件 file = Path(file_path) # 读取文件内容并将其存储在数据变量中 data = file.read_text() # 使用替换功能替换文本 data = data.replace(search_text, replace_text) # 在文本文件中写入替换的数据 file.write_text(data) return &quot;文本已替换&quot;def is_valid_url(string): regex = r&#39;^(http?://)?\\S+$&#39; return re.match(regex, string, re.IGNORECASE) is not Nonedef copyPic(): # 打开包含网址的文本文件（urls.txt） with open(file_path, &quot;r&quot;) as file: content = file.read() # 匹配以指定字符串开头并以 &#39; 结尾的正则表达式 pattern = r&#39;(https://关键词/.+?)\\\\&quot;&#39; urls = re.findall(pattern1, content) handle = fastdfs_trans.init() for url in tqdm(urls): try: # 判断url是否合法 if is_valid_url(url): # print(f&quot;找到网址：{url}&quot;) # 上传 resultUrl = handle.download_from_a_upload_to_b(url, extname=url.split(&#39;.&#39;)[-1]) # 文本替换 replacetext(url, resultUrl) except Exception as e: print(f&quot;Error during copy: {e}&quot;) print(f&#39;错误地址:{url}&#39;)if __name__ == &#39;__main__&#39;: copyPic()3.输出美化 用到了 tqdm 会生成比较优美的进度条## 总结 下次项目文件管理一定用minio！ 还有个问题 request做下载要带上浏览器header，公司域名做了限制！ 以及copilot天下第一，以上代码都是直接面向AI开发。" }, { "title": "【源码分析】logback日志配置及存储", "url": "/posts/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-logback%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%AD%98%E5%82%A8/", "categories": "", "tags": "springboot, logback", "date": "2024-04-11 11:12:07 +0800", "snippet": "起因 linux系统中springboot日志文件默认存在/tmp下，那么为什么会存储在这个位置呢,查阅可知 org/springframework/boot/logging/logback/base.xml 进行了相关定义 同时查看logback日志配置文件会有疑问，有些变量取自于defauts.xml中自定义，这些日志中的变量到底哪里来的呢。 源码分析AbstractLoggingSystem LogbackLoggingSystem LogbackLoggingSystem LogbackLoggingSystem " }, { "title": "python微信自动化框架wxauto进行消息采集转发", "url": "/posts/python%E5%BE%AE%E4%BF%A1%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6wxauto%E8%BF%9B%E8%A1%8C%E6%B6%88%E6%81%AF%E9%87%87%E9%9B%86%E8%BD%AC%E5%8F%91/", "categories": "", "tags": "微信自动化, wxauto, python", "date": "2024-03-07 16:07:37 +0800", "snippet": "需求 采集大群中含关键词的聊天记录，并进行自定义消息处理「脱敏、添加」，然后转发至指定群聊；同时存储信息至redis key为当天日期的set，判重发送 定时任务，每天定时发送公告，公告文件为txt环境微信版本: 3.9.8.15python版本: 3.11.6wxauto版本: 3.9.8服务器版本: 阿里云 2核4g windows 2012源码from wxauto import WeChatimport timeimport reimport hashlibimport redisimport datetimeimport schedule# 实例化微信对象wx = WeChat()listen_list = [ &#39;采集群1&#39;]# 转发目标群target_list = [ #&#39;test&#39;,]# 文末信息end_text = &quot;接单请联系群主 📞1234567890&quot;pool = redis.ConnectionPool(host=&#39;127.0.0.1&#39;, port=6379, decode_responses=True)def listen_group_chat(): for i in listen_list: wx.AddListenChat(who=i, savepic=False) # 添加监听对象并且自动保存新消息图片 # 持续监听消息 wait = 10 # 设置10秒查看一次是否有新消息 while True: msgs = wx.GetListenMessage() print(f&#39;采集时间：{datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)}&#39;) for chat in msgs: msg = msgs.get(chat) # 获取消息内容 print(f&#39;\\n-----&amp;gt;已获取新的消息,采集源：{chat.who}&#39;) # 获取每条聊天信息 for msg_item in msg: # 判断是否包含关键词 msg_content = msg_item[1] print(f&#39;消息内容:{msg_item}\\n&#39;) if keyword_match(msg_content): # 判断redis中是否存在 if not check_value(msg_content): print(&quot;开始自定义消息处理&quot;) # 消息脱敏处理 cleaned_text = msg_handler(msg_content) print(f&quot;处理结果:{cleaned_text}&quot;) # 转发至其他群 trans_to_another_group(target_list, cleaned_text) # redis缓存 set_cache(msg_content) print(&quot;-----&amp;gt;消息已缓存,处理结束\\n&quot;) else: print(&quot;-----&amp;gt;当日消息已存在， 不作处理\\n&quot;) else: print(&quot;-----&amp;gt;消息不包含关键词， 不作处理\\n&quot;) schedule.run_pending() time.sleep(wait)# 转发至其他群def trans_to_another_group(group_names, msg, at=None): print(f&quot;即将开始消息转发&quot;) for group_name in group_names: wx.ChatWith(group_name) if at: wx.AtSomeOne(msg, at) else: wx.SendMsg(msg) print(f&quot;消息已转发至{group_name}&quot;)# 消息处理器def msg_handler(text): # 去除原有手机号 phone_pattern = &quot;1[3-9]\\d{9}&quot; cleaned_text = re.sub(phone_pattern, &quot;&quot;, text) return f&#39;{cleaned_text}\\n{end_text}&#39;# 关键词匹配def keyword_match(text): # 定义要匹配的关键词列表 keywords = [&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;] xiaoqu_keywords = [&#39;area1&#39;, &#39;area2&#39;, &#39;area3&#39;] # 构建正则表达式 pattern = r&#39;|&#39;.join(map(re.escape, keywords + xiaoqu_keywords)) # 进行匹配并输出结果 matches = re.findall(pattern, text) if len(matches) &amp;gt; 0: return True else: return False# md5加密def md5_encode(text): md = hashlib.md5(text.encode()) # 创建md5对象 md5pwd = md.hexdigest() # md5加密 return md5pwd# redis set赋值 过期默认24小时def set_cache(value, timeout=24 * 60 * 60): r = redis.Redis(connection_pool=pool) key = datetime.datetime.now().strftime(&quot;%Y%m%d&quot;) r.sadd(key, value)# 判断redis中set值是否存在def check_value(value): key = datetime.datetime.now().strftime(&quot;%Y%m%d&quot;) r = redis.Redis(connection_pool=pool) return r.sismember(key, value) != 0# 广告播报def notice_broadcast(): file_path = &#39;notice1.txt&#39; try: # 打开文件并读取所有行（包括换行符） with open(file_path, &#39;r&#39;, encoding=&#39;utf-8&#39;) as file: content = file.read() trans_to_another_group(target_list, content) except FileNotFoundError: print(&quot;未找到该文件&quot;) except Exception as e: print(&quot;发生错误: &quot;, str(e))def schedule_init(): # 清空任务 schedule.clear() # 创建一个按3秒间隔执行任务 schedule.every().day.at(&quot;06:00&quot;).do(notice_broadcast) schedule.every().day.at(&quot;12:00&quot;).do(notice_broadcast) schedule.every().day.at(&quot;18:00&quot;).do(notice_broadcast) schedule.every().day.at(&quot;21:00&quot;).do(notice_broadcast)if __name__ == &#39;__main__&#39;: #需要注意 开启定时任务需要在监视循环内 并且初始化有先后顺序 schedule_init() listen_group_chat()效果图待优化 日志文件输出 记录入库 公告在线发布常见问题 报错 一般是python版本号问题 此工具需要保持远程连接，前台运行hook，windows自带工具不可用，本人使用todesk，其他软件自行搜索 远程桌面亦可，不过需要断开连接使用脚本保证不退出桌面，新建 exit.bat，每次点击脚本退出``` exit.bat@echo offfor %%i in (0,1,2,3,4,5,6,7,8,9) do (tscon %%i /dest:console )```" }, { "title": "奇技淫巧之oauth2利用state传参", "url": "/posts/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7%E4%B9%8Boauth2%E5%88%A9%E7%94%A8state%E4%BC%A0%E5%8F%82/", "categories": "", "tags": "oauth2", "date": "2023-08-22 16:12:25 +0800", "snippet": "问题公司多个子系统调用同一套oauth2认证，但是系统之间token是自定义的，现在需要A跳转到B指定页面，单点认证之后跳转的地址是固定的解决办法利用oauth2中的state参数，oauth官网上有这样一段 关于state描述的内容如果客户端希望在重定向 URL 中包含特定于请求的数据，则可以使用“state”参数来存储用户重定向后将包含的数据。 它可以对状态参数本身中的数据进行编码，也可以使用状态参数作为会话 ID 将状态存储在服务器上。步骤1一般state用于状态认证，是用于防止跨站请求伪造攻击，通常，state 参数会随着授权请求一起发送到授权服务器，授权服务器会在回调时返回该参数，客户端需要验证该参数和发送时的是否一致，以确保请求不是来自非法的攻击者。但是我们也可以利用state传递参数，我们在调用oauth2认证链接的时候将跳转地址传入注意需要将链接进行url编码，例如:http%3A%2F%2Fwww.baidu.compublic String login(@RequestParam(required = false) String backUrl) { // 传递参数response_type、client_id、state、redirect_uri String url = baseUrl + authorizeUrl + &quot;?response_type=code&amp;amp;&quot; + &quot;client_id=&quot; + clientId + &quot;&amp;amp;redirect_uri=&quot; + callbackUrl; //state记录跳转url if (StrUtil.isNotBlank(backUrl)) { url = url + &quot;&amp;amp;state=&quot; + backUrl; } url = url + &quot;&amp;amp;scope=ALL&quot;; return &quot;redirect:&quot; + url; }步骤2上一步我们传递了state参数，那么在回调的时候就会接收到state参数public String callback(@RequestParam(required = false) String code, @RequestParam(required = false) String state) { //……此处省略业务处理 换取token 获取用户信息 //state不为空取出重定向url，携带token进行跳转 否则跳转默认首页 if (StrUtil.isNotBlank(state)) { callbackFeUrl = state; } return &quot;redirect:&quot; + callbackFeUrl + &quot;?token=&quot; + r.get(&quot;token&quot;); }步骤3测试一下，B系统改造为以上代码，A系统前端页面挂载B系统跳转认证接口 http://xxxx/sso/dologin?backUrl=http%3A%2F%2Fwww.baidu.com,实现跳转到百度，此处百度替换为B系统指定页面。打完收工" }, { "title": "kkfile相关问题解决", "url": "/posts/kkfile%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/", "categories": "", "tags": "kkfile, docker", "date": "2023-05-17 11:05:50 +0800", "snippet": "问题1kkfile 无法访问解决方案中附件具体报错为某个文件地址 filenotfoud java.net.UnknownHostException:解决方法去掉docker 配置文件中”dns” : [“114.114.114.114”,”8.8.8.8”] 则可以正常访问 至于为什么加这一段是因为之前访问不了外网才加的问题2docker容器之间互相访问的问题，kkfile需要访问redis，由于容器重启ip不固定解决方法需要在kkfile run的时候就做好链接 –link 容器名:别名 ，一致则用一个就行docker run --restart=always -d \\ -e KK_BASE_URL=&quot;https://m.cicdi.com/jjfapt/kkfile&quot; \\ -e KK_CONTEXT_PATH=&quot;/kkfile&quot; \\ -v /home/cicdiAdmin/env/kkfile_docker:/opt/kkFileView-4.1.0-SNAPSHOT \\ -it -p 8012:8012 --name kkfile --link redis5 keking/kkfileview:v4.0.0原理是host中增加一条映射到容器ip，然后配置kkfile的文件，原来ip地址改为别名即可spring.redisson.address = ${KK_SPRING_REDISSON_ADDRESS:redis5:6379}相关命令vim /etc/docker/daemon.jsonsystemctl restart docker#进入容器内部docker exec -it kkfile bash#查看日志docker logs --tail=1000 kkfile -f#查看容器ipdocker inspect --format=&#39;{{.NetworkSettings.IPAddress}}&#39; redis-service#修改kkfile配置vim /home/xxx/env/kkfile_docker/config/application.properties" }, { "title": "easypoi使用map模板导出dict字典转换", "url": "/posts/easypoi%E4%BD%BF%E7%94%A8map%E5%AF%BC%E5%87%BAdict%E5%AD%97%E5%85%B8%E8%BD%AC%E6%8D%A2/", "categories": "", "tags": "easypoi, map, dict", "date": "2023-04-19 16:19:45 +0800", "snippet": "背景有一个导出原来用的map导出，现在有字段需要做数值转换模板处理申请人公司 申请时间 申请单号 产品名称 申请用户 状态 回收标记$fe:map1 t.companyName t.create_time t.id t.productName t.creator dict:applyStatus;t.status t.recycleFlag以上为excel模板内容 其中状态字段 dict:applyStatus;t.status，dict 代表这个是字段处理,applyStatus 字典key代码处理需要自定义字典转换接口，实现IExcelDictHandler 接口，然后在模板参数中设置一下我们来看一下源码public interface IExcelDictHandler { //获取字典所有值，带入下拉 default List&amp;lt;Map&amp;gt; getList(String dict) { return null; } //值-&amp;gt;名称 String toName(String var1, Object var2, String var3, Object var4); //名称-&amp;gt;值 String toValue(String var1, Object var2, String var3, Object var4);}例如我们自己实现的接口 @Override public String toName(String dict, Object obj, String name, Object value) { if (&quot;applyStatus&quot;.equals(dict)) { if (Integer.parseInt(String.valueOf(value))==0) { return &quot;申请中&quot;; }else if (Integer.parseInt(String.valueOf(value))==1) { return &quot;审核通过&quot;; }else if (Integer.parseInt(String.valueOf(value))==2) { return &quot;不通过&quot;; } } return &quot;-&quot;; }然后设置TemplateExportParams params = new TemplateExportParams( &quot;test.xlsx&quot;); params.setDictHandler(new IExcelDictHandlerImpl());即可完成值到名称的字典转换，也可以获取系统字典值进行查询转换" }, { "title": "2022小小的总结", "url": "/posts/2022%E5%B0%8F%E5%B0%8F%E7%9A%84%E6%80%BB%E7%BB%93/", "categories": "", "tags": "", "date": "2022-09-16 16:32:00 +0800", "snippet": "有两年没写笔记了上次还是2020年8月，去年在干嘛呢，回想起来也没有什么大事，怀孕工作，波澜不惊，大疫三年，做什么都没有动力。最近火了一个羊了个羊，广告主收益拿到软，国民爆款，上次这么火的游戏还是安卓初期年代的flip birds，广告收益也是爆了，创业方向也在不断尝试，花漾字体小程序也有了些许微弱极小的收益，家政互联网渠道取得了不错的成绩，每天都有成单。但是仍然没有一个稳定的收益渠道，目前有两条路在眼前，研究AI，nlp、cv、bi都有不错的前景，抑或继续后端前端小程序，后者赛道上想要突出不是很容易，AI方向更多能做一些改造一些突破一些挑战。今年7月宝宝出生，30不惑，道路似乎清明但是依旧有些许疑惑，加油！" }, { "title": "docker安装jenkins并部署服务", "url": "/posts/docker%E5%AE%89%E8%A3%85jenkins%E5%B9%B6%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1/", "categories": "", "tags": "docker, jenkins", "date": "2022-06-14 08:29:49 +0800", "snippet": "安装1、新建文件夹jenkins，新建docker-compose.yml文件，默认已安装docker-compose，拷贝如下配置。version: &#39;3.1&#39;services: jenkins: image: jenkins/jenkins:lts restart: always hostname: jenkins container_name: jenkins privileged: true # 特权模式 user: root ports: - 7777:8080 #web端口映射 - 50000:50000 environment: TZ: Asia/Shanghai JENKINS_JAVA_OPTIONS: -Djava.awt.headless=true -Xms512m -Xmx1024m -XX:MaxNewSize=512m -XX:MaxPermSize=512m #限制内存大小，小内存哭了 volumes: - /root/env/Jenkins/data:/var/jenkins_home # jenkins数据目录 - /root/env/apache-maven-3.5.4:/usr/local/maven # maven映射2、启动jenkins 执行dokcer-compose up -d 如果修改过配置文件，重新执行此命令会重建容器，除了挂载卷，修改内容都会消失。3、访问上面映射的端口 localhost:7777,密码可以查看docker logs -f jenkins。配置1、安装插件gitee、Publish Over SSH，配置maven地址、gitee账号。 此处注意maven文件需要配置成如下，在maven根目录新建ck文件夹，同时修改包下载路径，这样包会下载到映射的宿主机文件夹中，便于后期管理 &amp;lt;localRepository&amp;gt;${maven.home}/ck&amp;lt;/localRepository&amp;gt; 2、配置ssh访问，A要访问B主机(本案A为docker jenkins，B为宿主机)，需要A生成ssh凭证，并把公钥传给B，由于jenkins版本原因，生成ssh凭证代码为 ssh-keygen -m PEM -t rsa -b 4096,再通过ssh-copy-id 192.168.66.103把公钥传输到B。在配置页面进行配置后，点击Test Configuration后显示success即完成Publish Over SSH配置。部署这里选用是自由风格项目，拉取源代码后进行maven编译，编译完成后进行推送jar包到远程主机，本案为宿主机。然后执行项目下部署脚本，需要注意杀进程可能把jenkins部署进程杀掉，需要在脚本中加入如下配置export BUILD_ID=dontKillMesource /etc/profile#!/bin/bash#jar包文件夹路径及名称APP_NAME=/root/java/haoayi/jbhay.jar#日志文件路径及名称LOG_FILE=log/application_log.log#重启命令pid=`ps -ef | grep $APP_NAME | grep -v grep |awk &#39;{print $2}&#39;`if [ $pid ]thenkill -9 $pidfi# 启动jar包，指向日志文件，2&amp;gt;&amp;amp;1 &amp;amp; 表示打开或指向同一个日志文件export BUILD_ID=dontKillMesource /etc/profilenohup java -jar $APP_NAME --spring.profiles.active=pro &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;" }, { "title": "记一次生产环境fastdfs报错", "url": "/posts/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83fastdfs%E6%8A%A5%E9%94%99/", "categories": "", "tags": "运维, linux", "date": "2022-05-30 11:23:53 +0800", "snippet": "起因运营在上传文件的时候报错提示如下: 错误码 28 错误信息 没有足够的存储空间,经查询是fastdfs tracker中设置了服务器容量限制，当服务器剩余容量小于配置项的情况下（默认10%），会报如上错误。新分配的系统300g，不可能传满吧，然后查了一下有一块250g的硬盘没有挂载，系统盘44g容量已经所剩无几。解决方案 治标不治本的方法，调小配置项到5%，但是最后肯定会满。 扩容服务器，经过运维指导，成功扩大容量，操作如下。#查看硬盘df -h#把新盘做成pvpvcreate /dev/sdb#加到centos的vg里面vgextend centos /dev/sdb#扩容到指定盘lvextend -L +100G /dev/mapper/centos-root#逻辑扩容xfs_growfs /dev/mapper/centos-rootvgs就可以看到你vg里面还剩多少可以加的" }, { "title": "kkFileView实现文件优雅预览水印", "url": "/posts/kkFileView%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%BC%98%E9%9B%85%E9%A2%84%E8%A7%88%E6%B0%B4%E5%8D%B0/", "categories": "", "tags": "开源项目", "date": "2022-04-27 09:22:31 +0800", "snippet": "起因项目中包含大量office文件以及pdf需要实现在线预览，前端预览只能实现pdf预览且效果不佳项目介绍springboot搭建的文件预览服务，需要作为第三方服务器启动，原理是将文件通过本地安装的openoffice或者libreoffice转换成pdf，进而可以转换成图片，输出到前端模板中。且可以添加自定义水印，配置文件中也有多种选项可以配置#######################################不可动态配置，需要重启生效#######################################server.port = ${KK_SERVER_PORT:8012}server.servlet.context-path= ${KK_CONTEXT_PATH:/}server.servlet.encoding.charset = utf-8#文件上传限制spring.servlet.multipart.max-file-size=500MBspring.servlet.multipart.max-request-size=500MB## Freemarker 配置spring.freemarker.template-loader-path = classpath:/web/spring.freemarker.cache = falsespring.freemarker.charset = UTF-8spring.freemarker.check-template-location = truespring.freemarker.content-type = text/htmlspring.freemarker.expose-request-attributes = truespring.freemarker.expose-session-attributes = truespring.freemarker.request-context-attribute = requestspring.freemarker.suffix = .ftl# office-plugin## office转换服务的进程数，默认开启两个进程office.plugin.server.ports = 2001,2002## office 转换服务 task 超时时间，默认五分钟office.plugin.task.timeout = 5m#预览生成资源路径（默认为打包根路径下的file目录下）#file.dir = D:\\\\kkFileview\\\\file.dir = ${KK_FILE_DIR:default}#允许预览的本地文件夹 默认不允许任何本地文件被预览#file.dir = D:\\\\kkFileview\\\\local.preview.dir = ${KK_LOCAL_PREVIEW_DIR:default}#openoffice home路径#office.home = C:\\\\Program Files (x86)\\\\OpenOffice 4office.home = ${KK_OFFICE_HOME:default}#缓存实现类型，不配默认为内嵌RocksDB(type = default)实现，可配置为redis(type = redis)实现（需要配置spring.redisson.address等参数）和 JDK 内置对象实现（type = jdk）,cache.type = ${KK_CACHE_TYPE:jdk}#redis连接，只有当cache.type = redis时才有用spring.redisson.address = ${KK_SPRING_REDISSON_ADDRESS:127.0.0.1:6379}spring.redisson.password = ${KK_SPRING_REDISSON_PASSWORD:}#缓存是否自动清理 true 为开启，注释掉或其他值都为关闭cache.clean.enabled = ${KK_CACHE_CLEAN_ENABLED:true}#缓存自动清理时间，cache.clean.enabled = true时才有用，cron表达式，基于Quartz croncache.clean.cron = ${KK_CACHE_CLEAN_CRON:0 0 3 * * ?}#######################################可在运行时动态配置########################################提供预览服务的地址，默认从请求url读，如果使用nginx等反向代理，需要手动设置#base.url = https://file.keking.cnbase.url = ${KK_BASE_URL:default}#信任站点，多个用&#39;,&#39;隔开，设置了之后，会限制只能预览来自信任站点列表的文件，默认不限制#trust.host = file.keking.cn,kkfileview.keking.cntrust.host = ${KK_TRUST_HOST:default}#是否启用缓存cache.enabled = ${KK_CACHE_ENABLED:true}#文本类型，默认如下，可自定义添加simText = ${KK_SIMTEXT:txt,html,htm,asp,jsp,xml,json,properties,md,gitignore,log,java,py,c,cpp,sql,sh,bat,m,bas,prg,cmd}#多媒体类型，默认如下，可自定义添加media = ${KK_MEDIA:mp3,wav,mp4,flv}#是否开启多媒体类型转视频格式转换,目前可转换视频格式有：avi,mov,wmv,3gp,rm#请谨慎开启此功能，建议异步调用添加到处理队列，并且增加任务队列处理线程，防止视频转换占用完线程资源，转换比较耗费时间,并且控制了只能串行处理转换任务media.convert.disable = ${KK_MEDIA_CONVERT_DISABLE:false}#支持转换的视频类型convertMedias = ${KK_CONVERTMEDIAS:avi,mov,wmv,mkv,3gp,rm} #office类型文档(word ppt)样式，默认为图片(image)，可配置为pdf（预览时也有按钮切换）office.preview.type = ${KK_OFFICE_PREVIEW_TYPE:image}#是否关闭office预览切换开关，默认为false，可配置为true关闭office.preview.switch.disabled = ${KK_OFFICE_PREVIEW_SWITCH_DISABLED:false}#是否禁止下载转换生成的pdf文件pdf.download.disable = ${KK_PDF_DOWNLOAD_DISABLE:false}#是否禁用首页文件上传file.upload.disable = ${KK_FILE_UPLOAD_ENABLED:false}#预览源为FTP时 FTP用户名，可在ftp url后面加参数ftp.username=ftpuser指定，ä¸指定默认用配置的ftp.username = ${KK_FTP_USERNAME:ftpuser}#预览源为FTP时 FTP密码，可在ftp url后面加参数ftp.password=123456指定，不指定默认用配置的ftp.password = ${KK_FTP_PASSWORD:123456}#预览源为FTP时, FTP连接默认ControlEncoding(根据FTP服务器操作系统选择，Linux一般为UTF-8，Windows一般为GBK)，可在ftp url后面加参数ftp.control.encoding=UTF-8指定，不指定默认用配置的ftp.control.encoding = ${KK_FTP_CONTROL_ENCODING:UTF-8}#水印内容#例：watermark.txt = ${WATERMARK_TXT:凯京科技内部文件，严禁外泄}#如需取消水印，内容设置为空即可，例：watermark.txt = ${WATERMARK_TXT:}watermark.txt = ${WATERMARK_TXT:}#水印x轴间隔watermark.x.space = ${WATERMARK_X_SPACE:10}#水印y轴间隔watermark.y.space = ${WATERMARK_Y_SPACE:10}#水印字体watermark.font = ${WATERMARK_FONT:微软雅黑}#水印字体大小watermark.fontsize = ${WATERMARK_FONTSIZE:18px}#水印字体颜色watermark.color = ${WATERMARK_COLOR:black}#水印透明度，要求设置在大于等于0.005，小于1watermark.alpha = ${WATERMARK_ALPHA:0.2}#水印宽度watermark.width = ${WATERMARK_WIDTH:180}#水印高度watermark.height = ${WATERMARK_HEIGHT:80}#水印倾斜度数，要求设置在大于等于0，小于90watermark.angle = ${WATERMARK_ANGLE:10}项目整合 系统内下载采用的是http/https下载流url预览很多系统内不是直接暴露文件下载地址，而是请求通过id、code等参数到通过统一的接口，后端通过id或code等参数定位文件，再通过OutputStream输出下载，此时下载url是不带文件后缀名的，预览时需要拿到文件名，传一个参数fullfilename=xxx.xxx来指定文件名，示例如下 var originUrl = &#39;http://127.0.0.1:8080/filedownload?fileId=1&#39;; //要预览文件的访问地址var previewUrl = originUrl + &#39;&amp;amp;fullfilename=test.txt&#39;window.open(&#39;http://127.0.0.1:8012/onlinePreview?url=&#39;+encodeURIComponent(Base64.encode(previewUrl))); 项目还支持自定义传入水印，在预览url后面加上参数&amp;amp;watermarkTxt即可 var url = &#39;http://127.0.0.1:8080/file/test.txt&#39;; //要预览文件的访问地址window.open(&#39;http://127.0.0.1:8012/onlinePreview?url=&#39; + encodeURIComponent(url) + &#39;&amp;amp;watermarkTxt=&#39; + encodeURIComponent(&#39;动态水印&#39;)); 由于需要自定义传入水印，所以对原来的水印处理做了修改,代码拦截器位于AttributeSetFilter,其中拦截了watermarkTxt参数，并将其注入到当前请求request对象中。我们修改了参数值并且对齐进行base64转码操作，当然防君子不防小人，参数放在url请求中本来就是不安全的，只是做了些许转码能降低别人去除水印的难度。String watermarkTxt = new String(Base64.decodeBase64(request.getParameter(&quot;wmc&quot;)), StandardCharsets.UTF_8);request.setAttribute(&quot;watermarkTxt&quot;, watermarkTxt != null ? watermarkTxt : WatermarkConfigConstants.getWatermarkTxt());项目打包启动1.docker安装//maven编译，mvn clean package -DskipTests//进行打包操作 然后生成imagedocker build -t keking/kkfileview:v4.0.0 .//docker启动 并且可以传入配置文件中对应变量docker run --restart=always -d \\ -e KK_BASE_URL=&quot;https://预览地址/kkfile&quot; \\ -e KK_CONTEXT_PATH=&quot;/kkfile&quot; \\ -it -p 8012:8012 --name kkfile keking/kkfileview:v4.0.0 //KK_BASE_URL作为网站预览域名， //KK_CONTEXT_PATH 对应nginx中配置的location地址，如作为单独端口映射无二级域名则可以不填 server { listen 20303; server_name localhost; location /kkfile { proxy_pass http://localhost:8012; }}docker拓展：每次打包时间较长，可以采用映射文件夹，替换jar包方式来进行更新。通过查看Dockerfile可以确定容器内/opt/kkFileView-4.1.0-SNAPSHOT,存放jar包和配置文件。ENTRYPOINT [&quot;java&quot;,&quot;-Dfile.encoding=UTF-8&quot;,&quot;-Dspring.config.location=/opt/kkFileView-4.1.0-SNAPSHOT/config/application.properties&quot;,&quot;-jar&quot;,&quot;/opt/kkFileView-4.1.0-SNAPSHOT/bin/kkFileView-4.1.0-SNAPSHOT.jar&quot;]在宿主机内新建文件夹并在内部创建bin和config文件夹，并在创建容器的时候进行映射，之后每次编译后将jar包放入bin，配置文件放入config即可，可随时方便的修改配置文件了，同时下载和转换后的文件存在于同目录的file文件夹下。docker run --restart=always -d \\ -e KK_BASE_URL=&quot;https://预览地址/kkfile&quot; \\ -e KK_CONTEXT_PATH=&quot;/kkfile&quot; \\ -v 宿主机文件夹:/opt/kkFileView-4.1.0-SNAPSHOT \\ -it -p 8012:8012 --name kkfile keking/kkfileview:v4.0.02.源码编译上传，修改配置文件，运行bin中的start.sh启动，会自动安装libreoffice以及启动项目。（目前还未尝试）效果展示后续问题 虽然禁用下载按钮了，但是页面可以ctrl+s下载问题，定位到是pdf.js的问题，修改view.js源码,注释掉对应代码。 if (cmd === 1 || cmd === 8) { switch (evt.keyCode) { case 83: // eventBus.dispatch(&quot;download&quot;, { // source: window // }); // handled = true; break; ctrl+p打印依然可以保存文件,修改view.js源码,注释掉对应代码。 window.addEventListener(&quot;keydown&quot;, function (event) { if (event.keyCode === 80 &amp;amp;&amp;amp; (event.ctrlKey || event.metaKey) &amp;amp;&amp;amp; !event.altKey &amp;amp;&amp;amp; (!event.shiftKey || window.chrome || window.opera)) { // window.print(); event.preventDefault(); if (event.stopImmediatePropagation) { event.stopImmediatePropagation(); } else { event.stopPropagation(); } }}, true); " }, { "title": "【源码分析】springsecurity oauth2认证流程", "url": "/posts/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-oauth2%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/", "categories": "", "tags": "springsecurity, oauth2", "date": "2022-04-22 14:27:27 +0800", "snippet": "登录请求项目整合SpringSecurity后，所有http请求由其托管。当用户发起/oauth/token请求，其初始化的责任链包含一系列的拦截器会先对数据进行处理，验证path合法性以及获取clientId等操作，完成之后进入 TokenEndpoint的postAccessToken方法,再经过一系列域认证，然后进入生成token的操作。生成token生成token之前根据用户名调用用户服务接口来获取信息，对用户名密码进行校验，具体流程见之前的文章，通过之后就生成token，存入默认或者自定的tokenstore" }, { "title": "【源码分析】springmvc的消息转换器", "url": "/posts/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-springmvc%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8/", "categories": "", "tags": "java, SpringMVC", "date": "2022-04-20 09:40:19 +0800", "snippet": "疑问为什么springboot的Controller带上@RestController注解就可以直接返回json呢@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Controller@ResponseBodypublic @interface RestController { @AliasFor( annotation = Controller.class ) String value() default &quot;&quot;;}可以看到源码里带上了@ResonseBody注解，这就相当于给Controller里面每个方法增加了这个注解，该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。消息转换器 HttpMessageConverterMVC会添加几个默认的转换器，HttpMessageConverters维护了一个HttpMessageConverter集合。WebMvcConfigurationSupport类的方法addDefaultHttpMessageConverters中可以看到。而要动用这些消息转换器，需要在特定的位置加上@RequestBody和@ResponseBodySpringMVC会根据传入的Content-Type，对应的值就可以叫做是Media Type来确定消息转换器，如果没有合适的转换器，读则抛出HttpMediaTypeNotSupportedException，浏览器会收到一个415 Unsupported Media Type状态码；写则抛出HttpMediaTypeNotAcceptableException异常，浏览器会收到一个406 Not Acceptable状态码。举个例子 @PostMapping(&quot;/testRequestBody&quot;) @ResponseBody public Object testRequestBody(@RequestBody User user) { return user; }在SpringMVC进入testRequestBody方法前，会根据@RequestBody注解选择适当的HttpMessageConverter实现类来将请求参数解析到User对象中，具体来说是使用了MappingJackson2HttpMessageConverter类，它的canRead()方法返回true，然后它的read()方法会从请求中读出请求参数，绑定到testRequestBody()方法的User对象中。当SpringMVC执行testRequestBody方法后，由于返回值标识了@ResponseBody，SpringMVC将使用MappingJackson2HttpMessageConverter的write()方法，将结果作为json值写入响应报文，当然，此时canWrite()方法返回true。运作流程对于消息转换器的调用，都是在RequestResponseBodyMethodProcessor类中完成的，对于返回值的操作handleReturnValue调用了AbstractMessageConverterMethodProcessor中的writeWithMessageConverters方法，确定selectedMediaType后遍历消息转换器，根据canWrite来确定消息转换器，并对返回值进行处理；对于请求值操作调用AbstractMessageConverterMethodArgumentResolver的readWithMessageConverters方法，处理方式一致。参考文章：springMVC的消息转换器（Message Converter）Spring MVC系列（9）-HttpMessageConverter报文转换流程源码解析_云烟成雨TD的博客-CSDN博客Spring MVC系列（10）-使用fastjson自定义消息转换器_云烟成雨TD的博客-CSDN博客_fastjson 转换器SpringMVC源码剖析（五)-消息转换器HttpMessageConverter - 相见欢的个人空间 - OSCHINA - 中文开源技术交流社区" }, { "title": "docker中elastic增加密码访问", "url": "/posts/docker%E4%B8%ADelastic%E5%A2%9E%E5%8A%A0%E5%AF%86%E7%A0%81%E8%AE%BF%E9%97%AE/", "categories": "", "tags": "docker, elasticsearch", "date": "2022-04-19 09:40:19 +0800", "snippet": "配置文件修改进入容器内部sudo docker exec -it elastic /bin/bashvi打开config 下 elasticsearch.yml增加安全配置# 配置X-Packhttp.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;http.cors.allow-headers: Authorizationxpack.security.enabled: truexpack.security.transport.ssl.enabled: true重启docker中elasticdocker restart elastic修改密码bin/elasticsearch-setup-passwords interactive因为需要设置 elastic，apm_system，kibana，kibana_system，logstash_system，beats_system，remote_monitoring_user 这些用户的密码验证curl localhost:9200出现如下信息{&quot;error&quot;:{&quot;root_cause&quot;:[{&quot;type&quot;:&quot;security_exception&quot;,&quot;reason&quot;:&quot;missing authentication credentials for REST request [/]&quot;,&quot;header&quot;:{&quot;WWW-Authenticate&quot;:&quot;Basic realm=\\&quot;security\\&quot; charset=\\&quot;UTF-8\\&quot;&quot;}}],&quot;type&quot;:&quot;security_exception&quot;,&quot;reason&quot;:&quot;missing authentication credentials for REST request [/]&quot;,&quot;header&quot;:{&quot;WWW-Authenticate&quot;:&quot;Basic realm=\\&quot;security\\&quot; charset=\\&quot;UTF-8\\&quot;&quot;}},&quot;status&quot;:401}带上用户密码信息访问则返回正常信息curl localhost:9200 -u elastic:{password}RestHighLevelClient配置修改后端生产环境增加CredentialsProvider用于配置账号密码访问 HttpHost[] hh = clusterNodes.stream().map(x -&amp;gt; new HttpHost(x.split(&quot;:&quot;)[0], Integer.parseInt(x.split(&quot;:&quot;)[1]), &quot;http&quot;)).toArray(HttpHost[]::new); RestClientBuilder builder = RestClient.builder(hh); //增加账号密码配置 if (StringUtils.isNotBlank(userName) &amp;amp;&amp;amp; StringUtils.isNotBlank(password)) { CredentialsProvider credentialsProvider = new BasicCredentialsProvider(); credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(userName, password)); builder.setHttpClientConfigCallback(f -&amp;gt; f.setDefaultCredentialsProvider(credentialsProvider)); } RestHighLevelClient client = new RestHighLevelClient(builder); return client;前端访问9200端口需要在header中增加basic认证拼接用户名密码信息" }, { "title": "【源码分析】springsecurity密码模式校验密码", "url": "/posts/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-springsecurity%E5%AF%86%E7%A0%81%E6%A8%A1%E5%BC%8F%E5%A6%82%E4%BD%95%E6%A0%A1%E9%AA%8C%E5%AF%86%E7%A0%81/", "categories": "", "tags": "springsecurity, oauth2", "date": "2022-04-12 09:39:00 +0800", "snippet": "oauth2认证流程TokenGranter给用户分发OAuth2AccessToken,根据grantType(password,authorization-code)和TokenRequest（requestParameters,clientId,grantType）授予人OAuth2AccessToken令牌。实现AbstractTokenGranter的类有5种。其中如果用password的方式进行验证，那么TokenGranter类型是ResourceOwnerPasswordTokenGranter，该类中重写了getOAuth2Authentication方法，里面调用了authenticationManager.authenticate()方法。userAuth = this.authenticationManager.authenticate(userAuth);用户可自行定义granter类继承AbstractTokenGranter，重写getOAuth2Authentication()方法，并将该granter类添加至CompositeTokenGranter中。五种实现类如下图：密码模式源码分析验证码用户名密码调用 AbstractUserDetailsAuthenticationProvider中的authenticate方法，至于为什么调用这个服务，可以观察到其缺省实现 ProviderManager中一行代码if (provider.supports(toTest))即表示如果服务支持 toTest 这个类型： Class&amp;lt;? extends Authentication&amp;gt; toTest = authentication.getClass();那么它就会调用这个服务的认证方法：result = provider.authenticate(authentication);supports 方法是接口AuthenticationProvider中的一个方法。我们打开一个实现类，以AbstractUserDetailsAuthenticationProvider抽象类为例这个方法的实现表示这个服务支持 UsernamePasswordAuthenticationToken 这个类型的Tokenreturn UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);当传入的Token类型是UsernamePasswordAuthenticationToken并且在服务列表中循环到这个服务的具体实现服务时，就会触发该实现的认证方法密码校验AbstractUserDetailsAuthenticationProvider中authenticate方法先去获取用户信息，调用自定义的UserDetailsService中loadUserByUsername方法，然后在对密码进行校验操作 //获取用户信息 user = retrieveUser(username,(UsernamePasswordAuthenticationToken) authentication); …… …… this.preAuthenticationChecks.check(user); #用于校验密码 this.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);调用了DaoAuthenticationProvider中的验证密码方法 protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException { if (authentication.getCredentials() == null) { this.logger.debug(&quot;Authentication failed: no credentials provided&quot;); throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } else { String presentedPassword = authentication.getCredentials().toString(); if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) { this.logger.debug(&quot;Authentication failed: password does not match stored value&quot;); throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } } }参考链接：OAuth2 源码分析(一.核心类）SpringCloud - Oauth2增加短信验证码验证登录" }, { "title": "【微服务专题】springboot springsecurity oauth2自定义异常", "url": "/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%93%E9%A2%98-springboot-springsecurity-oauth2%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8/", "categories": "", "tags": "springboot, springsecurity, oauth2", "date": "2022-04-11 10:28:34 +0800", "snippet": "oauth2认证流程调用认证中心的/oauth/token，header中带上basic认证的clientid和secret;用户名密码模式对应的DaoAuthenticationProvider，定义了UserDetailsService来获取用户信息和密码模式passwordEncoder;获取信息失败或者认证错误用DefaultWebResponseExceptionTranslator来进行异常处理，实现的接口WebResponseExceptionTranslator，translate方法用于异常处理。要实现自定义异常，我们继承后重写方法即可。自定义异常输出1.重写translate来自定义异常/** * @author TAO * @description: SpringSecurity OAuth2 异常翻译器，统一捕获授权时异常信息处理 * @date 2021/10/1 16:14 */@Slf4j@Componentpublic class Auth2ResponseExceptionTranslator implements WebResponseExceptionTranslator { private ThrowableAnalyzer throwableAnalyzer = new DefaultThrowableAnalyzer(); @Override public ResponseEntity translate(Exception e) throws Exception { Throwable[] causeChain = throwableAnalyzer.determineCauseChain(e); Exception ase = null;// 异常栈获取 OAuth2Exception 异常 ase= (AuthenticationException) throwableAnalyzer.getFirstThrowableOfType(AuthenticationException.class, causeChain); if (ase != null) { return handleOAuth2Exception(new ExtendOAuth2Exception(e.getMessage(), e)); } ase = (UnsupportedGrantTypeException) throwableAnalyzer .getFirstThrowableOfType(UnsupportedGrantTypeException.class, causeChain); if (ase != null) { return handleOAuth2Exception(new ExtendOAuth2Exception(e.getMessage(), e)); } ase = (AccessDeniedException) throwableAnalyzer.getFirstThrowableOfType(AccessDeniedException.class, causeChain); if (ase != null) { return handleOAuth2Exception(new ExtendOAuth2Exception(ase.getMessage(), ase)); } ase = (HttpRequestMethodNotSupportedException) throwableAnalyzer .getFirstThrowableOfType(HttpRequestMethodNotSupportedException.class, causeChain); if (ase != null) { return handleOAuth2Exception(new ExtendOAuth2Exception(ase.getMessage(), ase)); } ase = (OAuth2Exception) throwableAnalyzer.getFirstThrowableOfType(OAuth2Exception.class, causeChain); if (ase != null) { return handleOAuth2Exception((OAuth2Exception) ase); } // 不包含上述异常则服务器内部错误 return handleOAuth2Exception(new ExtendOAuth2Exception(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase(), e)); } private ResponseEntity&amp;lt;OAuth2Exception&amp;gt; handleOAuth2Exception(OAuth2Exception e) { int status = e.getHttpErrorCode(); HttpHeaders headers = new HttpHeaders(); headers.set(&quot;Cache-Control&quot;, &quot;no-store&quot;); headers.set(&quot;Pragma&quot;, &quot;no-cache&quot;); if (status == HttpStatus.UNAUTHORIZED.value() || (e instanceof InsufficientScopeException)) { headers.set(&quot;WWW-Authenticate&quot;, String.format(&quot;%s %s&quot;, OAuth2AccessToken.BEARER_TYPE, e.getSummary())); } return new ResponseEntity&amp;lt;&amp;gt;(new ExtendOAuth2Exception(e.getMessage(),e), headers, HttpStatus.valueOf(status)); }}2.异常继承类以及序列化类扩展OAuth2Exception/*** @description: 扩展OAuth2Exception* @author TAO* @date 2021/9/29 22:14*/@JsonSerialize(using = ExtendOAuth2ExceptionSerializer.class)public class ExtendOAuth2Exception extends OAuth2Exception { @Getter private String dataMsg; public ExtendOAuth2Exception(String msg) { super(msg); } public ExtendOAuth2Exception(String msg, Throwable t) { super(msg, t); } public ExtendOAuth2Exception(String msg, String dataMsg) { super(msg); this.dataMsg = dataMsg; }}ExtendOAuth2Exception返回格式序列化/*** @description: ExtendOAuth2Exception返回格式序列化* @author TAO* @date 2021/9/29 22:42*/public class ExtendOAuth2ExceptionSerializer extends StdSerializer&amp;lt;ExtendOAuth2Exception&amp;gt; { public ExtendOAuth2ExceptionSerializer() { super(ExtendOAuth2Exception.class); } @Override public void serialize(ExtendOAuth2Exception e, JsonGenerator gen, SerializerProvider serializerProvider) throws IOException { gen.writeStartObject(); gen.writeObjectField(&quot;code&quot;, String.valueOf(e.getHttpErrorCode())); gen.writeStringField(&quot;msg&quot;, e.getMessage()); gen.writeStringField(&quot;data&quot;, e.getDataMsg()); gen.writeEndObject(); }}3.配置自定义异常解析器 /** * 访问端点配置。tokenStore、tokenEnhancer服务 */ @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain(); List&amp;lt;TokenEnhancer&amp;gt; tokenEnhancers = new ArrayList&amp;lt;&amp;gt;(); tokenEnhancers.add(tokenEnhancer()); tokenEnhancerChain.setTokenEnhancers(tokenEnhancers); endpoints.allowedTokenEndpointRequestMethods(HttpMethod.GET, HttpMethod.POST) //支持请求 .tokenEnhancer(tokenEnhancerChain)//token增强 .authenticationManager(authenticationManager)//密码模式 .tokenStore(tokenStore())//token存入redis .exceptionTranslator(new Auth2ResponseExceptionTranslator()) // 设置自定义的异常解析器 .userDetailsService(userDetailsService); }至此，security oauth2认证已经能返回指定格式的返回体{ &quot;code&quot;: &quot;400&quot;, &quot;msg&quot;: &quot;Unsupported grant type: password1&quot;, &quot;data&quot;: null}UsernameNotFoundException无法抛出的问题经过对源码的分析 ，hideUserNotFoundExceptions决定了是否转换异常类型。AbstractUserDetailsAuthenticationProvider.class try { user = retrieveUser(username, (UsernamePasswordAuthenticationToken) authentication); } catch (UsernameNotFoundException notFound) { logger.debug(&quot;User &#39;&quot; + username + &quot;&#39; not found&quot;); if (hideUserNotFoundExceptions) { throw new BadCredentialsException(messages.getMessage( &quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;)); } else { throw notFound; } }解决方法就是把实现类中hideUserNotFoundExceptions修改值为false，并且替换掉默认的。public class WebSecurityConfig extends WebSecurityConfigurerAdapter { private UserDetailsService userDetailsService; /** * 用户验证 */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //替换默认DaoAuthenticationProvider auth.authenticationProvider(authenticationProvider()); } /** * 用于抛出UsernameNotFoundException */ @Bean public DaoAuthenticationProvider authenticationProvider() { DaoAuthenticationProvider provider = new DaoAuthenticationProvider(); provider.setHideUserNotFoundExceptions(false); provider.setUserDetailsService(userDetailsService); provider.setPasswordEncoder(passwordEncoder()); return provider; }如此一来，我们在loadUserByUsername中抛出的异常可以正常反馈{ &quot;code&quot;: &quot;400&quot;, &quot;msg&quot;: &quot;用户不存在&quot;, &quot;data&quot;: null}" }, { "title": "mac上docker mysql启动错误问题排查", "url": "/posts/mac%E4%B8%8Adocker-mysql%E5%90%AF%E5%8A%A8%E9%94%99%E8%AF%AF%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/", "categories": "", "tags": "docker, mysql, mac", "date": "2022-04-06 16:25:54 +0800", "snippet": "问题mbp版本2021款14寸m1 pro芯片，系统Monterey，今天突然发现本地docker中的mysql启动失败，具体报错如下Error invoking remote method &#39;docker-start-container&#39;: Error: (HTTP code 500) server error - error while creating mount source path &#39;/host_mnt/private/var/db/timezone/tz/2021a.3.0/zoneinfo/Asia/Shanghai&#39;: mkdir /host_mnt/private/var/db/timezone/tz/2021a.3.0: operation not permitted排查看了下大概是挂载的时间有问题，创建的时候又没权限，查了下本地目录下确实没这个2021a.3.0文件夹,但是mysql挂载的是/etc/localtime，映射到具体的时间是2022a.1.0,不知道docker抽什么风，重启都不好使.谷歌搜了一圈看到一个差不多的问题，解决方法是复制一份改名字。尝试了一下，mac有sip完整性保护，系统级别的文件夹都不允许操作，于是关闭sip,具体方式是重启后长按开机键，进入系统终端里运行命令csrutil disable关闭。运行如下命令，成功创建文件夹，再运行mysql镜像成功跑起来了。sudo cp -rfp /private/var/db/timezone/tz/2022a.1.0 /private/var/db/timezone/tz/2021a.3.0" }, { "title": "docker定期备份mysql", "url": "/posts/docker%E5%AE%9A%E6%9C%9F%E5%A4%87%E4%BB%BDmysql/", "categories": "", "tags": "运维, linux, mysql", "date": "2022-03-30 08:24:21 +0800", "snippet": "原因这不是前面迁移了两个系统吗。所有运维都得自己来，数据无价，为了防止猪队友操作，所以准备定期备份mysql数据。就在备份完的之后n天，新入职的张三就把测试库导到生产库了，得，我就是预言家。mysql设置首先，mysql备份用到mysqldump命令，需要在mysql配置文件中增加如下配置，否则需要在命令行中加上用户密码。[mysqldump]user=xxxpassword=xxx脚本 注意点：以下所有操作都为root权限。vim mysqlback.sh复制粘贴如下脚本# 保留10天数据，# mysql-service为安装docker中mysql服务名称docker exec -i mysql-service bash&amp;lt;&amp;lt;&#39;EOF&#39;# 判断目录是不是已经存在，如果不存在则创建if [ ! -d &quot;/backups/mysql&quot; ]; then mkdir -p /backups/mysqlfi# xxx 为数据库的名称mysqldump xxx &amp;gt; /backups/mysql/backups_$(date +%Y%m%d).sql#删除超过10天的数据rm -f /backups/mysql/backups_$(date -d -10day +%Y%m%d).sqlexitEOF# 宿主机操作：判断目录是不是已经存在，如果不存在则创建if [ ! -d &quot;/home/admin/backups/mysql&quot; ]; then mkdir -p /home/admin/backups/mysqlfi# 将docker中的备份的数据拷贝到宿主机上。docker cp mysql-service:/backups/mysql/backups_$(date +%Y%m%d).sql /home/admin/backups/mysql#删除超过10天的数据rm -f /home/admin/backups/mysql/backups_$(date -d -10day +%Y%m%d).sql定时任务打开定时任务配置crontab -e增加如下命令59 23 * * * sh /home/admin/env/mysqlbak.sh" }, { "title": "centos7允许指定ip访问端口", "url": "/posts/centos7%E5%85%81%E8%AE%B8%E6%8C%87%E5%AE%9Aip%E8%AE%BF%E9%97%AE%E7%AB%AF%E5%8F%A3/", "categories": "", "tags": "运维, linux", "date": "2022-03-11 09:38:33 +0800", "snippet": "起因部署在系统内网的环境被扫描到mysql5.7.26存在诸多安全问题，ssh端口也存在安全隐患，既然是内网应用，那就指定应用ip访问端口即可。解决步骤centos7用的是firewall防火墙，开启防火墙，对指定端口限制ip访问即可，mysql 3306端口用于远程访问，ssh端口10022用于运维。#设置指定ip访问端口firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;xxxx&quot; port protocol=&quot;tcp&quot; port=&quot;10022&quot; accept&quot;firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;xxxx&quot; port protocol=&quot;tcp&quot; port=&quot;3306&quot; accept&quot;firewall-cmd --reload#移除防火墙开启的端口firewall-cmd --permanent --zone=public --remove-port=10022/tcpfirewall-cmd --reload#重启防火墙firewall-cmd --reload#查看端口firewall-cmd --zone=public --list-ports#添加端口firewall-cmd --permanent --zone=public --add-port=3306/tcp#删除端口firewall-cmd --permanent --zone=public --remove-port=10022/tcp#查看规则firewall-cmd --list-rich-rules#添加规则firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;xxxx&quot; port protocol=&quot;tcp&quot; port=&quot;10022&quot; accept&quot;#删除规则firewall-cmd --permanent --remove-rich-rule &#39;查看规则内容&#39;启动：systemctl start firewalld关闭：systemctl stop firewalld查看状态：systemctl status firewalld开机禁用：systemctl disable firewalld开机启用：systemctl enable firewalld端口转发添加（例如3306 -&amp;gt; 3336）：firewall-cmd --permanent --zone=public --add-forward-port=port=3336:proto=tcp:toport=3306:toaddr=删除：firewall-cmd --permanent --remove-forward-port=port=3306:proto=tcp:toport=3336:toaddr=查看转发的端口：firewall-cmd --list-forward-ports后续问题照说改过了没问题，上次测试了两台机器也无法telnet通对应端口；但是在后一次扫描后还是暴露了一些漏洞，经过排查，docker重启后会绕开防火墙开启访问。这是因为docker 默认用的是iptable(用户态)客户端工具管理的docker的filter，如果systemctl start docker 在systemctl start firewalld 这样会把docker的规则破坏，主要是FORWARD规则破坏，比较省事的操作就是关闭docker的iptables。vim /etc/docker/daemon.json添加如下规则{ &quot;iptables&quot;:false}重启dockersystemctl restart docker" }, { "title": "docker环境安装以及常见中间件部署", "url": "/posts/docker%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%83%A8%E7%BD%B2/", "categories": "", "tags": "运维", "date": "2022-03-07 23:31:57 +0800", "snippet": "安装docker（离线方式）1.下载 Docker2.解压压缩文件tar -zxvf docker-19.03.8.tgz3.将解压好的 Docker 文件复制到 /usr/bin 目录下cp docker/* /usr/bin/4.将 docker 注册为服务vim /etc/systemd/system/docker.service输入以下内容[Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.serviceWants=network-online.target [Service]Type=notify# the default is not to use systemd for cgroups because the delegate issues still# exists and systemd currently does not support the cgroup feature set required# for containers run by dockerExecStart=/usr/bin/dockerd --selinux-enabled=false --insecure-registry=127.0.0.1ExecReload=/bin/kill -s HUP $MAINPID# Having non-zero Limit*s causes performance problems due to accounting overhead# in the kernel. We recommend using cgroups to do container-local accounting.LimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinity# Uncomment TasksMax if your systemd version supports it.# Only systemd 226 and above support this version.#TasksMax=infinityTimeoutStartSec=0# set delegate yes so that systemd does not reset the cgroups of docker containersDelegate=yes# kill only the docker process, not all processes in the cgroupKillMode=process# restart the docker process if it exits prematurelyRestart=on-failureStartLimitBurst=3StartLimitInterval=60s [Install]WantedBy=multi-user.target 此处的–insecure-registry=127.0.0.1（此处改成你私服ip）设置是针对有搭建了自己私服Harbor时允许docker进行不安全的访问，否则访问将会被拒绝。5.启动 docker 为 docker.service 文件添加执行权限 chmod +x /etc/systemd/system/docker.service 重新加载配置文件 systemctl daemon-reload 启动 systemctl start docker 设置开机启动 systemctl enable docker.service 查看 docker 服务状态 systemctl status docker 如何离线安装docker镜像docker仓库地址 在外网机器上拉取镜像并查看 docker images 将镜像打包成tar压缩文件,使用ll命名可以看到打包好的文件docker save -o mysql-5.7.26.tar mysql:5.7.26 将打包好的tar文件下载到U盘等介质(使用ftp工具) 拷贝到内网linux并载入docker docker load -i mysql-5.7.26.tarmysql镜像安装1、挂载外部配置和数据安装mkdir -p /data/docker/mysql &amp;amp;&amp;amp; mkdir -p /data/docker/mysql/logs &amp;amp;&amp;amp; mkdir -p /data/docker/mysql/data/创建my.cnf配置文件vim /data/docker/mysql/my.cnf内容：[mysqld]user=mysqlcharacter-set-server=utf8default_authentication_plugin=mysql_native_passwordsecure_file_priv=/var/lib/mysqlexpire_logs_days=7sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTIONmax_connections=1000[client]default-character-set=utf8[mysql]default-character-set=utf82.启动镜像docker run --restart=always -d \\-v /data/docker/mysql/data/:/var/lib/mysql \\-v /data/docker/mysql/logs:/var/log/mysql \\-v /data/docker/mysql/my.cnf:/etc/mysql/my.cnf \\-v /etc/localtime:/etc/localtime \\-p 23306:3306 --name mysql-service -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.26 --lower_case_table_names=1 3.进入镜像docker exec -it mysql-service bashdocker 容器 修改mysql密码1.进入 mysql 容器docker exec -it mysql-service /bin/bash4.重新进入容器输入命令root为用户名 默认密码mysql -u root -p5.修改密码的命令update mysql.user set authentication_string=password(&#39;新密码&#39;) where user=&#39;root&#39; ;FLUSH PRIVILEGES; 6.开启远程访问use mysql; grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;xxx&#39; with grant option;FLUSH PRIVILEGES; 7.导入文件docker cp solutiondocker.sql mysql-service:/tmp/进入mysql 选择数据库然后source 之前的文件本机远程登录命令 mysql -h 127.0.0.1 -P 23306 -uroot -p8.数据导出docker exec -it mysql-service mysqldump -uroot -pPassword solution_manage &amp;gt; /home/admin/env/docker_db.sqlredis镜像安装1.配置文件移到redis目录下mkdir -p /data/docker/redis/data2.启动镜像docker run -p 6379:6379 --name redis-service --privileged=true --restart always \\-v /data/docker/redis/redis.conf:/etc/redis/redis.conf \\-v /data/docker/redis/data:/data \\-d redis:5-alpine3.13 --appendonly yes --requirepass root 安装nginx+fastdfs1.查看fastdfs的镜像docker search fastdfs2.拉取镜像docker pull delron/fastdfs这个版本的镜像是比较全的，含有fastdfs以及nginx以及其相关的配置。3.启动tracker服务docker run --restart=always -d --network=host --name tracker -v /home/admin/env/fdfs/tracker:/var/fdfs -v /etc/localtime:/etc/localtime delron/fastdfs tracker4.启动storage服务 ip不可以用127.0.0.1 ,这个镜像内部含有nginx的相关模块 如果需要公网访问，需要设置为公网ip，且22122,23000，8888端口需要开放安全组或者防火墙。docker run --restart=always -d --network=host --name storage -e TRACKER_SERVER=172.16.0.83:22122 -v /home/admin/env/fdfs/storage:/var/fdfs -v /etc/localtime:/etc/localtime delron/fastdfs storage5.查看启动后的状态docker ps -a6.修改nginx端口（这里默认是8888）–也可以不修改这里以修改为8874为例子：6.1.进入storage容器：docker exec -it storage bashfdfs_monitor /etc/fdfs/storage.conf6.2.修改storage内部http.server_port,vi /etc/fdfs/storage.conf,可以看到在最后一行 http.server_port=8888，将其改成为http.server_port=8874即可。6.3.因为修改了storage，所以还需要修改nginx，保持一致：vi /usr/local/nginx/conf/nginx.conf，然后将其内部的 server {listen 8888; …} 改成 server {listen 8874; …}6.4.命令退出:exit7.最后需要重启容器：docker restart storage8.测试是否配置成功拷贝一个txt文件到目录/var/fdfs 进入storage容器：docker exec -it storage bash进入fdfs目录：cd /var/fdfs运行命令：/usr/bin/fdfs_upload_file /etc/fdfs/client.conf test.txt运行成功后会返回地址： group1/M00/00/00/rBFYll7Qw7uAPuhdAAAABncc3SA243.txt9.浏览器测试安装elasticsearch1.设置max_map_count不能启动es会启动不起来查看max_map_count的值 默认是65530cat /proc/sys/vm/max_map_count1重新设置max_map_count的值sysctl -w vm.max_map_count=2621442.下载镜像并运行#拉取镜像docker pull elasticsearch:7.13.2docker run -e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; -e &quot;discovery.type=single-node&quot; -d -p 9200:9200 -p 9300:9300 --restart=always --name=elastic elasticsearch:7.13.23.curl localhost:9200 有返回即为成功安装4.安装中文分词docker exec -it elastic /bin/bash安装ES中文分词插件 IK./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.13.2/elasticsearch-analysis-ik-7.13.2.zip安装ES拼音分词插件./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-pinyin/releases/download/v7.13.2/elasticsearch-analysis-pinyin-7.13.2.zip" }, { "title": "记一次复杂项目迁移", "url": "/posts/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%8D%E6%9D%82%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB/", "categories": "", "tags": "运维", "date": "2022-03-03 16:54:22 +0800", "snippet": "网络环境新的服务器与老的服务器网段不同，只能单向访问老服务器，且无法本地访问，需通过堡垒机运维，此为前提。环境安装涉及到java、maven基本环境安装，maven主要用来打包程序，git拉下来方便在线部署；docker安装，用于安装一些中间件mysql、redis、elasticSearch、fastDFS。具体安装部署会在下一篇文章总结。文件迁移项目1的文件存储在公司公共的fastDFS库，迁移方案主要有方案1:采用节点扩容,由于网络不通，放弃；方案2:直接拷贝，让运维看了下19G，拷完不知道猴年马月了，而且项目中所占只有1G左右，放弃；最后想了一个偏路子，写代码获取库里的文件地址，下载然后上传到新部署的fdfs，再update库里的地址。过程有一点波折，有些业务表里存的直接是地址，需要再找出来替换掉。项目2的文件存储在远古的ftp上，写了代码按照地址路径下载所有文件，然后在老服务器上压缩，大小达到9个G，但是新服务器可以访问到,到底是内网速度飞快100M/s，通过代码的下载接口直接在新服务器上下好然后解压。代码改造下，原先本地开发的就是直接文件存储没有上文件服务器，老代码掏出来改改直接上传下载齐活。代码部署前端nginx配下，后端jar包启动，调整下端口,然后申请开通域名映射，一系列接口白名单等等，齐活。问题解决1.mysql大小写问题，docker创建的时候就要给mysql设置好。2.springboot jar包启动缓慢，一开始很正常，后来改过防火墙，每次都要2分钟左右。排查以为是随机值问题，修改无果。最后排查到mysql连接过慢，可能是防火墙重启导致docker安装的东西有问题，重启docker，重启mysql。代码可以正常快速启动好。" }, { "title": "jekyll安装chirpy主题全流程", "url": "/posts/jekyll%E5%AE%89%E8%A3%85chirpy%E4%B8%BB%E9%A2%98%E5%85%A8%E6%B5%81%E7%A8%8B/", "categories": "", "tags": "博客, jekyll", "date": "2022-02-16 23:20:20 +0800", "snippet": "安装jekyll此步骤略过，网上较多，全程需要科学上网，需要注意的是mac自带的ruby会有问题，升级下rvm安装高版本ruby可以正常使用。此处使用的版本是ruby 2.6.6p146 (2020-03-31 revision 67876) [x86_64-darwin21]，吐槽下ruby的环境安装真是一言难尽，劝退一大波人。选择主题此处直接forkChirpy Starter，拿回来改改就好使了，主题风格极简深得我心。 注意点：项目fork后需要修改Gemfile的源地址，source &quot;https://gems.ruby-china.com&quot;，这时候运行bundle会安装相关依赖,运行jekyll s即可看到初始化首页，_config.yml中配置livereload: true,然后运行jekyll serve --force_polling可以开启实时预览。博客配置博客配置位于_config.yml，修改中文lang: zh-CN以及一些基础信息；默认不编译时间大于当前时间的文章，可增加future: true去除限制。重点说下评论配置，本人选用的是giscus，利用github自带的discussion讨论区功能来进行评论管理，使用giscus有三个先决条件，可以参考giscus-cn。按照配置完成后，我们博客配置文件中comments.active后填入giscus，giscus后repo填的是自己准备当做评论功能的repo，格式用户名/项目名，repo_id是项目id，category是discussion分类，category_id是分类id，mapping是映射方式可以选择很多种，id不清楚可以打开上述网址后，输入仓库等一系列配置后，在下方的script脚本中看到对应数据,完成后即可在文章下方看到评论区。安装部署区别于hexo需要编译后再上传文件，github支持jekyll自动编译部署，上传代码后github自动调用workflow中脚本生成一个gh_pages分支,此时在setting-pages里面选择分支设置好域名即可，相关教程可以搜索pages部署博客,enjoy it！" }, { "title": "freemarker+itext实现超级简历pdf", "url": "/posts/freemarker+itext%E5%AE%9E%E7%8E%B0%E8%B6%85%E7%BA%A7%E7%AE%80%E5%8E%86pdf/", "categories": "", "tags": "", "date": "2022-01-07 17:56:18 +0800", "snippet": " 思路：尝试实现超级简历的pdf样式，分析是通过html模板结合freemarker占位循环，配合itext3支持css3高级特性渲染富文本生成pdf。1.设计html模板，关键词部分用freemarker标签占位处理&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;zh&quot;&amp;gt;&amp;lt;head&amp;gt; &amp;lt;style type=&quot;text/css&quot;&amp;gt; // 样式省略 &amp;lt;/style&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div id=&quot;head&quot; class=&quot;space&quot;&amp;gt; &amp;lt;div class=&quot;title center&quot;&amp;gt; ${username} &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;center&quot;&amp;gt; ${phone} 丨${email} &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;center&quot;&amp;gt; ${address} &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;center&quot;&amp;gt; ${homepage} &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;center&quot;&amp;gt; ${birthday?string(&#39;yyyy-MM-dd&#39;)} 丨${gender} &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;center&quot;&amp;gt;  ${currentJob} 丨${expJob} &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;#if skill?? &amp;amp;&amp;amp;skill!=&#39;&#39;&amp;gt; &amp;lt;div class=&quot;small-title&quot;&amp;gt;专业技能&amp;lt;/div&amp;gt; &amp;lt;hr/&amp;gt; &amp;lt;div class=&quot;content space&quot;&amp;gt; ${skill} &amp;lt;/div&amp;gt;&amp;lt;/#if&amp;gt;&amp;lt;#if works?? &amp;amp;&amp;amp; (works?size &amp;gt; 0)&amp;gt; &amp;lt;div class=&quot;small-title&quot;&amp;gt;工作经历&amp;lt;/div&amp;gt; &amp;lt;hr/&amp;gt; &amp;lt;div class=&quot;content space&quot;&amp;gt; &amp;lt;#list works as t&amp;gt; &amp;lt;p class=&quot;left company&quot;&amp;gt;${t.company}&amp;lt;/p&amp;gt; &amp;lt;p class=&quot;right&quot;&amp;gt;${t.startAt} - ${t.endAt}&amp;lt;/p&amp;gt; &amp;lt;p class=&quot;clear&quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;${t.dept} |${t.job}&amp;lt;/p&amp;gt; ${t.description} &amp;lt;/#list&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/#if&amp;gt;&amp;lt;#if edus?? &amp;amp;&amp;amp; (edus?size &amp;gt; 0)&amp;gt; &amp;lt;div class=&quot;small-title&quot;&amp;gt;教育经历&amp;lt;/div&amp;gt; &amp;lt;hr/&amp;gt; &amp;lt;div class=&quot;content space&quot;&amp;gt; &amp;lt;#list edus as t&amp;gt; &amp;lt;p class=&quot;left company&quot;&amp;gt;${t.university}&amp;lt;/p&amp;gt; &amp;lt;p class=&quot;right&quot;&amp;gt;${t.startAt?string(&#39;yyyy-MM&#39;)} - ${t.endAt?string(&#39;yyyy-MM&#39;)}&amp;lt;/p&amp;gt; &amp;lt;p class=&quot;clear&quot;&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;${t.major} |${t.degree}&amp;lt;/p&amp;gt; ${t.description} &amp;lt;/#list&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/#if&amp;gt;&amp;lt;#if summary?? &amp;amp;&amp;amp;summary!=&#39;&#39;&amp;gt; &amp;lt;div class=&quot;small-title&quot;&amp;gt;个人总结&amp;lt;/div&amp;gt; &amp;lt;hr/&amp;gt; &amp;lt;div class=&quot;content space&quot;&amp;gt; ${summary} &amp;lt;/div&amp;gt;&amp;lt;/#if&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;2.freemarker渲染html// 获取模板,并设置编码方式Template template = freemarkerCfg.getTemplate(htmlTmp);template.setEncoding(&quot;UTF-8&quot;);// 合并数据模型与模板template.process(data, out); //将合并后的数据和模板写入到流中，这里使用的字符流out.flush();createPdf(out.toString(),outputStream);3.itext生成pdf//css3高级特性支持ITextRenderer render = new ITextRenderer();ITextFontResolver fontResolver = render.getFontResolver();fontResolver.addFont(FONT, BaseFont.IDENTITY_H, BaseFont.EMBEDDED);// 解析html生成pdfrender.setDocumentFromString(content);render.layout();render.createPDF(outputStream);4.前端接收文件流展示response.setHeader(&quot;Content-Type&quot;, &quot;application/pdf &quot;);response.setContentType(&quot;application/pdf ;charset=utf-8&quot;);//不加👇就直接预览response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + URLEncoder.encode(&quot;test.pdf&quot;, &quot;UTF-8&quot;));我这里是通过小程序展示" }, { "title": "freemarker导出富文本到word", "url": "/posts/freemarker%E5%AF%BC%E5%87%BA%E5%AF%8C%E6%96%87%E6%9C%AC%E5%88%B0word/", "categories": "", "tags": "java", "date": "2021-04-30 00:03:55 +0800", "snippet": " 场景：富文本编辑器中的文本信息存储到数据库，为html语言，需要把富文本解析然后导出到word中。由于不存在图片信息，故此文不做讨论。尝试方法 使用easy-poi导出word，单个字段方便展示，但是富文本信息无法解析，list类型数据需要解析也没有良好的解决方法，尽管有遍历，但是仅限于表格之中。归根结底是由于poi对于word的支持不太行。 使用freemarker标签占位word对应位置，然后另存为mht格式，类似html的一种文件格式。思路解析 编辑word模板，freemarker标签占位 idea中打开对应文件，另存之后会产生格式错乱，需要修改占位符号正确，最后另存为ftl格式。 （重要）解析需要展示的文本为3Dus-asci编码值，使用freemarker渲染模板。核心转换，将对象中所有字符换成3Dus-asci，十进制Accsii码，mht可以识别转换为html格式public static String string2Ascii(String source){ if(source==null || source==&quot;&quot;){ return null; } StringBuilder sb=new StringBuilder(); char[] c=source.toCharArray(); for(char item : c){ String itemascii=&quot;&quot;; if(item&amp;gt;=19968 &amp;amp;&amp;amp; item&amp;lt;40623){ itemascii=itemascii=&quot;&amp;amp;#&quot;+(item &amp;amp; 0xffff)+&quot;;&quot;; }else{ itemascii=item+&quot;&quot;; } sb.append(itemascii); } return sb.toString(); }参考文档chaofanHb/ExpordWord java填充word文档（带有富文本）" }, { "title": "绝色", "url": "/posts/%E7%BB%9D%E8%89%B2/", "categories": "", "tags": "生活随笔", "date": "2020-01-09 19:13:07 +0800", "snippet": "是的，2020的第一场雪来了，依然比以往稍晚一些，距离2012年刀郎的那首歌已经过去了18年若逢新雪初霁满月当空下面平铺着皓影上面流转着亮银而你带笑地向我步来月色与雪色之间你是第三种绝色" }, { "title": "Transmit用iterm2替代终端", "url": "/posts/Transmit%E7%94%A8iterm2%E6%9B%BF%E4%BB%A3%E7%BB%88%E7%AB%AF/", "categories": "", "tags": "mac, transmit, iterm2, 终端", "date": "2019-12-23 23:43:53 +0800", "snippet": " mac下sftp工具transmit自带打开terminal采用的是默认，想要替换成iterm2 首先创建一个文件随便什么名字 ,例如 transmit-iterm-patch.applescript，保存代码如下 命令行运行 defaults write com.panic.Transmit OpenTerminalScriptPath ~/transmit-iterm-patch.applescript,++注意地址一定要写对++ 用transmit中的打开终端即可打开iterm2的界面-- Run the following cmd to make Transmit marry iterm2 as its Terminal partner:-- defaults write com.panic.Transmit OpenTerminalScriptPath ~/transmit-iterm-patch.applescripton openTerminal(location, remoteHost, serverPort) -- Prepare sshCmd and cmd: set sshCmd to &quot;&quot; set cmd to &quot;cd \\&quot;&quot; &amp;amp; location &amp;amp; &quot;\\&quot;&quot; if ((count of remoteHost) is greater than 0) then set sshCmd to &quot;ssh &quot; &amp;amp; remoteHost if (serverPort is greater than 0) then set sshCmd to sshCmd &amp;amp; &quot; -p &quot; &amp;amp; serverPort end if end if -- Check whether the application was open already. tell application &quot;System Events&quot; set wasOpen to (exists (processes where name is &quot;iTerm&quot;)) or (exists (processes where name is &quot;iTerm2&quot;)) end tell -- Do operations on iTerm. tell application &quot;iTerm&quot; activate -- Create window: if (count of windows) is 0 then create window with default profile else if wasOpen then tell first window to create tab with default profile end if end if -- Inside iterm2&#39;s window: tell first window if ((count of sshCmd) is greater than 0) then tell current session to write text sshCmd delay 0.5 end if tell current session to write text cmd end tell end tellend openTerminal参考文档终端替换攻略脚本代码github地址" }, { "title": "onos&amp;mininet基于SDN模拟ip+光安装指北", "url": "/posts/onos-mininet%E5%9F%BA%E4%BA%8ESDN%E6%A8%A1%E6%8B%9Fip-%E5%85%89%E5%AE%89%E8%A3%85%E6%8C%87%E5%8C%97/", "categories": "", "tags": "onos, mininet", "date": "2019-05-20 18:39:58 +0800", "snippet": " onos mininet 真挺坑的，国内研究人很少，相关文档基本靠墙外，记录下过程吧1.onos安装 基于1.9.0安装onos onos github下载源码，切换1.9.0分支 设置环境变量，修改 tools/dev/bash_profile 中各项配置，系统变量.profile中加入如下 source ~/documents/work/onos/tools/dev/bash_profile #刚刚下载onos目录export ONOS_APPS=&quot;drivers,drivers.optical,openflow,proxyarp,optical,onos-jsptpd-sdn&quot; #onos-jsptpd-sdn为另外开发appexport PATH=&quot;$PATH:$HOME/bin&quot; 项目目录中运行 ok ,此时会下载buck并打包运行项目，会比较慢，一定要挂梯子 op打包命令，ok clean debug会开启远程端口，配合idea可以实现调试2.mininet安装 onos 官网教程cdgit clone git://github.com/mininet/mininetcd mininetwget &#39;https://wiki.onosproject.org/download/attachments/4164175/multi_controller.patch?version=1&amp;amp;modificationDate=1443649770762&amp;amp;api=v2&#39; -O multi_controller.patchgit apply multi_controller.patchsudo ./util/install.sh -3fnv# role back CPqD to a version known to workcdcd ~/ofsoftswitch13/make cleangit reset --hard 8d3df820f7487f541b3f5862081a939aad76d8b5sudo make installcdsudo mn --test pingall # this should work3.linc-oe安装 模拟光网络cdgit clone git://github.com/mininet/mininetcd mininetwget &#39;https://wiki.onosproject.org/download/attachments/4164175/multi_controller.patch?version=1&amp;amp;modificationDate=1443649770762&amp;amp;api=v2&#39; -O multi_controller.patchgit apply multi_controller.patchsudo ./util/install.sh -3fnv# role back CPqD to a version known to workcdcd ~/ofsoftswitch13/make cleangit reset --hard 8d3df820f7487f541b3f5862081a939aad76d8b5sudo make installcdsudo mn --test pingall # this should work4.新建拓扑推送到onos mininet安装补丁后可以推送多个onos主机，实现集群 sudo -E python onos/tools/test/topos/opticalTestBig.py $OC1 $OC2 $OC3 5.实现rest接口操作mininetgithub上找到一个项目 mininetrest，二次开发了下，实现操作link，启动mininet的时候会启动一个web服务器监听请求操作mininet参考文档使用buck安装ONOSonos ip+光环境配置" }, { "title": "java8特性学习1：Lamda表达式", "url": "/posts/java8%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A01-Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F/", "categories": "", "tags": "java", "date": "2019-05-10 17:53:27 +0800", "snippet": " 语言在进步，人也要进步简介Lamda表达式，读作λ表达式，Lambda（大写Λ，小写λ）读音：lam (b) da（兰木达）[‘læmdə]它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。如定义了一个函数式接口如下：@FunctionalInterfaceinterface GreetingService { void sayMessage(String message);}那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：GreetingService greetService1 = message -&amp;gt; System.out.println(&quot;Hello &quot; + message);Lamda语法有三种形式： (参数) -&amp;gt;单行语句； (参数) -&amp;gt;{多行语句}； (参数) -&amp;gt;表达式；括号（）可以大致理解为就是方法，里面是参数变量，在上面的例子中()-&amp;gt;System.out.println(“Hello World!”) 前面的()代表void 它没有入参，所以为空，-&amp;gt;后面是一个单行语句；如果-&amp;gt;后面是多行语句，需要用{ }装起来，每条语句后需要有分号;-&amp;gt;后面也可以是一个表达式，如：a+b等。 lambda写的好可以极大的减少代码冗余，同时可读性也好过冗长的内部类，匿名类new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;线程操作！&quot;); }});　　现在，使用Lamda表达式，简单写为：new Thread(()-&amp;gt;System.out.println(&quot;线程操作！&quot;));变量lambda表达式可以访问给它传递的变量，访问自己内部定义的变量，同时也能访问它外部的变量。不过lambda表达式访问外部变量有一个非常重要的限制：变量不可变（只是引用不可变，而不是真正的不可变）。由于是实现匿名内部类效果，引用的外部变量需要时final，现在java8对这个限制做了优化，可以不用显示使用final修饰，但是编译器隐式当成final来处理。在lambda中，this不是指向lambda表达式产生的那个SAM对象，而是声明它的外部对象。方法引用&amp;amp;构造器引用 objectName::instanceMethod例如 System.out::println等同于x-&amp;gt;System.out.println(x)； ClassName::staticMethod例如 Math::max等同于(x, y)-&amp;gt;Math.max(x,y) ClassName::instanceMethod例如 String::toUpperCase等于x-&amp;gt;x.toUpperCase() ClassName::new 构造器引用例如 BigDecimal::new等同于x-&amp;gt;new BigDecimal(x)。Stream Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。 Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。Collection接口有一个stream方法，所以其所有子类都都可以获取对应的Stream对象。public interface Collection&amp;lt;E&amp;gt; extends Iterable&amp;lt;E&amp;gt; { //其他方法省略 default Stream&amp;lt;E&amp;gt; stream() { return StreamSupport.stream(spliterator(), false); }}+--------------------+ +------+ +------+ +---+ +-------+| stream of elements +-----&amp;gt; |filter+-&amp;gt; |sorted+-&amp;gt; |map+-&amp;gt; |collect|+--------------------+ +------+ +------+ +---+ +-------+forEachStream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：Random random = new Random();random.ints().limit(10).forEach(System.out::println);mapmap 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);// 获取对应的平方数List&amp;lt;Integer&amp;gt; squaresList = numbers.stream().map( i -&amp;gt; i*i).distinct().collect(Collectors.toList()); map和foreach区别在于map是1：1映射，foreach中则可以进行操作输出filterfilter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：List&amp;lt;String&amp;gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);// 获取空字符串的数量int count = strings.stream().filter(string -&amp;gt; string.isEmpty()).count();limitlimit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：Random random = new Random();random.ints().limit(10).forEach(System.out::println);sortedsorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：Random random = new Random();random.ints().limit(10).sorted().forEach(System.out::println);并行（parallel）程序parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：List&amp;lt;String&amp;gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);// 获取空字符串的数量int count = strings.parallelStream().filter(string -&amp;gt; string.isEmpty()).count();我们可以很容易的在顺序运行和并行直接切换。CollectorsCollectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：List&amp;lt;String&amp;gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);List&amp;lt;String&amp;gt; filtered = strings.stream().filter(string -&amp;gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(&quot;筛选列表: &quot; + filtered);String mergedString = strings.stream().filter(string -&amp;gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));System.out.println(&quot;合并字符串: &quot; + mergedString);统计另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。List&amp;lt;Integer&amp;gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&amp;gt; x).summaryStatistics(); System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());System.out.println(&quot;所有数之和 : &quot; + stats.getSum());System.out.println(&quot;平均数 : &quot; + stats.getAverage());" }, { "title": "个人博客开启https", "url": "/posts/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%90%AFhttps/", "categories": "", "tags": "", "date": "2019-02-22 18:51:29 +0800", "snippet": " hexo搭建的博客，域名namecheap托管，内容放在github pages，想要开启https cloudflare提供免费的ssl服务，dns加速等功能，注册选择免费服务，添加博客域名，扫描dns后continue，获得两个dns地址。 登陆namecheap，自定义dns填入. 设置cloudflare–Crypto加密选项为flexible,没有证书的情况下选择这个，自己不需要证书.把下面https重定向的全部开启。—Page Rules设置https301重定向https 检查网页资源中不得引用http资源，否则https成功但是不显示绿锁。" }, { "title": "JavaMail排雷指南", "url": "/posts/JavaMail%E6%8E%92%E9%9B%B7%E6%8C%87%E5%8D%97/", "categories": "", "tags": "java", "date": "2018-12-21 16:55:48 +0800", "snippet": " 有需求在用户下单后发送提醒邮件给客服邮箱，实现了一下发现其中还是蛮多注意事项准备事项 要发邮件肯定需要一个用来发件邮箱，百度大法说需要一个开通时间比较久的邮箱，因为自己用的就是一年前开通的邮箱就没去验证。 用的163邮箱，开通授权码，最重要开启smtp服务，用来发送邮件 至此，邮箱准备工作进行完毕 开发工作 引入maven仓库 &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;javax.mail&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mail&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.7&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 2.编写代码-javamail配置 smtp服务 25是正常端口 465是ssl端口，由于阿里云出于安全因素禁掉了25端口，只能采用465端口static { props = new Properties(); props.setProperty(&quot;mail.transport.protocol&quot;, PROTOCOL); props.setProperty(&quot;mail.smtp.host&quot;, HOST); props.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;); props.put(&quot;mail.smtp.socketFactory.port&quot;, &quot;465&quot;); //ssl props.put(&quot;mail.smtp.port&quot;, &quot;465&quot;); // ssl props.setProperty(&quot;mail.smtp.auth&quot;, IS_AUTH); props.setProperty(&quot;mail.debug&quot;, IS_ENABLED_DEBUG_MOD); }3.编写代码-javamail发送 注意点 本机环境与linux环境编码不同，如果对标题正文不进行转码，中文会乱码/** * 防止中文乱码 * @param text * @return */ private static String transcode(String text){ try { return MimeUtility.encodeText(text,MimeUtility.mimeCharset(&quot;gb2312&quot;), null); } catch (UnsupportedEncodingException e) { e.printStackTrace(); return null; } } /** * 发送简单的文本邮件 */ public static boolean sendTextEmail(String to, String content) throws Exception { try { // 创建Session实例对象 Session session1 = Session.getDefaultInstance(props); // 创建MimeMessage实例对象 MimeMessage message = new MimeMessage(session1); // 设置发件人 message.setFrom(new InternetAddress(from)); // 设置邮件主题 String mail_subject = &quot;您有新的订单【&quot;+ DateUtils.formatToSS(new Date())+&quot;】&quot;; message.setSubject(transcode(mail_subject)); // 设置收件人 message.setRecipient(RecipientType.TO, new InternetAddress(to)); String nick= transcode(&quot;江北好阿姨&quot;); message.setFrom(new InternetAddress(nick+&quot; &amp;lt;&quot;+from+&quot;&amp;gt;&quot;)); // 设置发送时间 message.setSentDate(new Date()); // 设置纯文本内容为邮件正文 message.setContent(content, &quot;text/plain;charset=utf-8&quot;); //生成邮件正文 // 保存并生成最终的邮件内容 message.saveChanges(); // 获得Transport实例对象 Transport transport = session1.getTransport(); // 打开连接 transport.connect(uname, upass); // 将message对象传递给transport对象，将邮件发送出去 transport.sendMessage(message, message.getAllRecipients()); // 关闭连接 transport.close(); return true; } catch (Exception e) { e.printStackTrace(); return false; } 打完收工" }, { "title": "阿里云域名更换证书", "url": "/posts/%E9%98%BF%E9%87%8C%E4%BA%91%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%8D%A2%E8%AF%81%E4%B9%A6/", "categories": "", "tags": "服务器, 证书", "date": "2018-12-19 21:51:47 +0800", "snippet": "由于小程序需要https接口，所以去年申请了阿里云的ssl免费证书，年底快到期了，免费不能续费只能重新申请一个。 不得不说，阿里云免费证书藏得真够深的 购买免费证书 验证dns，域名下面解析证书指定的配置 等待审批 下载证书，我服务器用的nginx转发所以只要配置下nginx的就好了#小程序httpsserver { listen 443; server_name xxxx; #填写绑定证书的域名 ssl on; ssl_certificate cert/xxxxx; #填写绑定证书的文件路径 pem ssl_certificate_key cert/xxxxx;#填写绑定证书的文件路径 key ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / { proxy_pass http://localhost:8080; }} 遇到一个小坑，新买的服务器443端口没开，导致访问不了，安全组配置下就好了 打完收工，打开浏览器可以看到已经网站前面的小绿锁拉 " }, { "title": "linux 开启ssh掉坑", "url": "/posts/linux-%E5%BC%80%E5%90%AFssh%E6%8E%89%E5%9D%91/", "categories": "", "tags": "", "date": "2018-12-04 22:36:54 +0800", "snippet": "百度搜其它问题的时候不小心把etc的权限提的太高，导致ssh服务出问题winscp putty都连接不上了，运维小白最后终于定位问题/usr/sbin/sshd -T 查看ssh启动问题重新给权限 chmod 600 -R /etc/sshd启动搞定 service sshd start，顺利连接上" }, { "title": "2018年中学习计划", "url": "/posts/2018%E5%B9%B4%E4%B8%AD%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/", "categories": "", "tags": "", "date": "2018-07-10 21:27:03 +0800", "snippet": " 2018上半年，有惊喜有收获也有失去以及落寞。总结一哈 内容：工作空余学习了angular，vue，小程序开发框架，结合自己的想法做了咩咩集市H5（angular）以及后台（vue），后面基于h5项目重构了咩咩集市小程序端，以及目前的江北好阿姨项目的持续开发。 收获：发现之前写的一些代码都很大优化空间,写前端逻辑代码对于后台思维也有帮助,公司不是前后端分离，作为java开发经常要前端来一手，有时候都恨这愚蠢的模式。目前把前后台交互摸得也算一清二楚，前端到后台，再到前端打包扔到nginx，后台扔到tomcat服务器都算得心应手。 展望一下下半年 后台技术重点研究下微服务（SpringCloud或者Dubbo）以及对于多线程高并发的了解程度 前端学习下React，发现越来越多的大厂都在使用React，特别是阿里对其情有独钟，今天刚看到京东也出了一个基于React的小程序框架Taro 上线江北好阿姨小程序，持续迭代 最后，生活安逸不应该成为我们停滞不前的借口。生命不止，奋斗不息，与君共勉。" }, { "title": "小程序从入门到放弃 第一回", "url": "/posts/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-%E7%AC%AC%E4%B8%80%E5%9B%9E/", "categories": "", "tags": "小程序, 全栈", "date": "2018-01-12 00:17:12 +0800", "snippet": " 去年的小程序到今天大放异彩的小游戏，腾讯可算是给小xx操碎了心，但是官方文档的不全到开发社区的参差不齐，让开发者从一个坑爬起来又掉下另一个坑第一回 狗用户拒绝点授权 开发者敢怒不敢言先说下小程序用户登录授权的流程，拿一张官方的时序图wx.login 【请注意此处不需用户授权】调用接口获取登录凭证（code）进而换取用户登录态信息重点说一哈原理是调用wx.login获取一个用户登录凭证code到后台交换，然后会获得openid、session_key,微信不建议openid作为key,我是用uuid作为key，openid和session_key放到map里作为value，然后放进redis，设置一个不要太长的过期时间，然后把key作为3rd_session传给小程序端。 java的童鞋后台接口推荐个贼好用的sdk=&amp;gt;可能是目前最好最全的微信Java开发工具包（SDK） public String login(String code) { if (StringUtils.isBlank(code)) { return &quot;empty jscode&quot;; } try { //交换code WxMaJscode2SessionResult session = this.wxService.getUserService() .getSessionInfo(code); String thirdSession = TokenGenerator.generateValue(); Map&amp;lt;String, Object&amp;gt; val = new HashMap&amp;lt;String, Object&amp;gt;(); val.put(&quot;openid&quot;, session.getOpenid()); val.put(&quot;sessionkey&quot;, session.getSessionKey()); //存储到redis redisUtils.set(thirdSession, val,session.getExpiresin()); //TODO 此处可以根据业务进行操作 //返回3rdSession给小程序 return JsonUtils.toJson(thirdSession); } catch (WxErrorException e) { this.logger.error(e.getMessage(), e); return e.toString(); } } 小程序把这个值存储到本地，每次请求头文件带上这个3rd_session，后台做校验。 // 登录 wx.login({ success: res =&amp;gt; { // 发送 res.code 到后台换取 openId, sessionKey, unionId console.log(res.code) if (res.code) { //发起网络请求 wx.request({ url: &#39;xxxxxxx&#39;, data: { code: res.code }, success: function (res) { wx.setStorageSync(&#39;3rdSession&#39;, res.data) } }) } else { console.log(&#39;获取用户登录态失败！&#39; + res.errMsg) } } })过期时间redis的是服务器的session过期时间，保证用户关闭小程序后session失效即安全性,同时微信code和微信服务器换取的session_key也有过期时间，要用到下文的wx.checkSession来判断是否过期，重新调用wx.login获取_wx.checkSession 通过上述接口获得的用户登录态拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者只需要调用wx.checkSession接口检测当前用户登录态是否有效。登录态过期后开发者可以再调用wx.login获取新的用户登录态wx.checkSession({ success: function(){ //session 未过期，并且在本生命周期一直有效 }, fail: function(){ //登录态过期 wx.login() //重新登录 .... }})wx.getUserInfo (此处会弹出授权窗口)最恶心的来了，用户一旦拒绝授权，要等10分钟或者删除小程序重新打开才能授权。前辈们总结了好几套方案比如无限弹授权、首页提示授权，鹅厂爸爸当然不给这么搞了，用户体验最高。微信发布了一个公告: 为了给用户提供更好的小程序环境，我们约定在一段时间后（具体时间会做通知），若还出现以下情况&amp;gt;（包括但不限于），将无法通过审核 初次打开小程序就弹框授权用户信息。 未处理用户拒绝授权的情况。 强制要求用户授权。 最好的解决方案就是在需要调用授权的地方调用,如果用户拒绝，弹出提示警告无法使用部分功能,以下代码弹出授权设置框 // 获取用户信息 wx.getSetting({ success: res =&amp;gt; { console.log(res.authSetting[&#39;scope.userInfo&#39;]) if (res.authSetting[&#39;scope.userInfo&#39;]) { // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框 wx.getUserInfo({ success: res =&amp;gt; { // 可以将 res 发送给后台解码出 unionId this.globalData.userInfo = res.userInfo // 由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回 // 所以此处加入 callback 以防止这种情况 if (this.userInfoReadyCallback) { this.userInfoReadyCallback(res) } } }) } } })解密敏感信息wx.getUserInfo 参数名 类型 必填 说明 withCredentials Boolean 否 是否带上登录态信息 获取用户信息，withCredentials 为 true 时需要先调用 wx.login 接口。此参数默认为false，可以直接获取头像、昵称等非敏感信息，敏感信息可以获取到地理信息等。暂时还未用到，待续…参考地址：https://my.oschina.net/mrlingli/blog/873263http://www.ifanr.com/minapp/886723https://www.cnblogs.com/nosqlcoco/p/6105749.html" }, { "title": "angular-cli 打包文件过大解决方案", "url": "/posts/angular-cli-%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/", "categories": "", "tags": "angular", "date": "2018-01-10 21:53:29 +0800", "snippet": "写好的angular网站首页访问速度很慢，探究一番发现问题所在并解决ng build生成文件过大可以看到5.4M，访问时间达到了12s，一开始以为是什么依赖过大，后来发现不经过压缩生成的文件就是这么大。解决方案：1.配合命令压缩打包 ng build --prod --aot --build-optimizer 2.再配合nginx开启gzip压缩 可以看到最后文件只有400kb大小，访问速度达到最快最后感谢pcrobot道友一同解决问题" }, { "title": "springboot 引用第三方jar包以及打包", "url": "/posts/springboot-%E5%BC%95%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9jar%E5%8C%85%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8C%85/", "categories": "", "tags": "java, maven, springboot, jar", "date": "2018-01-10 00:33:11 +0800", "snippet": "项目springboot架构，maven打包需要war包由于业务需要使用马云爸爸的jar包，而他的jar包是根据用户权限及时生成的，所以中央maven库没有。百度谷歌一番，本地使用没有问题，引用代码如下：&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.miemie.analyzer&amp;lt;/groupId&amp;gt; &amp;lt;!-- 随意--&amp;gt; &amp;lt;artifactId&amp;gt;tbk&amp;lt;/artifactId&amp;gt; &amp;lt;!-- 随意--&amp;gt; &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt; &amp;lt;!-- 随意--&amp;gt; &amp;lt;scope&amp;gt;system&amp;lt;/scope&amp;gt; &amp;lt;!-- /system 表示不读取本地仓库，读取指定系统文件，默认为compile（编译测试打包都会放进去）--&amp;gt; &amp;lt;systemPath&amp;gt;${project.basedir}/lib/xxxx.jar &amp;lt;!-- src同级目录新建一个lib文件夹，将需要的jar包扔进去--&amp;gt; &amp;lt;/systemPath&amp;gt;&amp;lt;/dependency&amp;gt; 问题主要在打包，如果正常打包部署，服务器会报nosuchclass错误，因为没打进去啊,那么就要解决第三方jar包无法打入的问题打包大致有几种解决方法： 本地安装jar包到maven仓库，直接引用，不用像上面代码一样写范围和路径了。简单粗暴，打jar/war包都可以，但是缺点很明显，每台电脑都需要安装一遍。 统一配置 (包括打jar和war包)，这样不用每台pull项目的机器都安装jar包 打jar包，在pom文件中的build标签下加上如下的配置```xml org.springframework.boot spring-boot-maven-plugin ${project.basedir}/lib BOOT-INF/lib/ **/*.jar src/main/resources BOOT-INF/classes/ + 打war包，要用到maven-war-plugin 插件```xml&amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;webResources&amp;gt; &amp;lt;resource&amp;gt; &amp;lt;directory&amp;gt;${project.basedir}/lib&amp;lt;/directory&amp;gt; &amp;lt;targetPath&amp;gt;WEB-INF/lib/&amp;lt;/targetPath&amp;gt; &amp;lt;includes&amp;gt; &amp;lt;!-- 把所有lib下的jar包打进WEB-INF/lib里面--&amp;gt; &amp;lt;include&amp;gt;**/*.jar&amp;lt;/include&amp;gt; &amp;lt;/includes&amp;gt; &amp;lt;/resource&amp;gt; &amp;lt;/webResources&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; 至此，应该都可以愉快的玩耍了，把你的jar/war包丢到服务器吧。" }, { "title": "2018/1/4 南京初雪", "url": "/posts/%E5%8D%97%E4%BA%AC%E5%88%9D%E9%9B%AA/", "categories": "", "tags": "随笔", "date": "2018-01-04 16:38:30 +0800", "snippet": "盗个图先❅雪❅路上各种树给压劈叉，骑着小电驴一路漂移到了地铁站 雾凇沆砀，天与云与山与水，上下一白。湖上影子，惟长堤一痕、湖心亭一点、与余舟一芥、舟中人两三粒而已。走的也不算晚吧，都是扫雪的人，完全没有以上的意境。这种天，在家捂被窝才是极好的 XD" } ]
